/**
 * ExportFormatPreview Component
 * Work Order #39 - Multi-Format Export Capabilities
 * 
 * Format-specific preview component that allows users to see sample output
 * before generating full exports in PDF, JSON, and CSV formats.
 */

import React, { useState, useMemo, useCallback } from 'react';
import styles from './ExportFormatPreview.module.css';

// ============================================================================
// Constants
// ============================================================================

const PREVIEW_SAMPLE_SIZE = 3; // Number of sample items to show in preview

const FORMAT_PREVIEW_CONFIGS = {
  pdf: {
    name: 'PDF Report Preview',
    icon: 'ðŸ“„',
    description: 'Professional report layout with formatted detection results'
  },
  json: {
    name: 'JSON Data Preview',
    icon: 'ðŸ“‹',
    description: 'Complete detection result data structure'
  },
  csv: {
    name: 'CSV Table Preview',
    icon: 'ðŸ“Š',
    description: 'Tabular data for spreadsheet analysis'
  }
};

// ============================================================================
// Preview Generators
// ============================================================================

/**
 * Generate PDF preview data
 */
const generatePDFPreview = (data) => {
  return {
    title: 'Deepfake Detection Report',
    subtitle: 'SecureAI Analysis Results',
    sections: [
      {
        title: 'Executive Summary',
        content: `Analysis completed with ${data.overall_confidence || 85}% confidence. The video has been classified as ${data.is_fake ? 'FAKE' : 'AUTHENTIC'}.`
      },
      {
        title: 'Detection Details',
        content: `Processing time: ${data.processing_time_ms || 1250}ms\nModel used: Enhanced CNN Ensemble\nFrame analysis: ${data.total_frames || 120} frames processed`
      },
      {
        title: 'Blockchain Verification',
        content: data.blockchain_hash ? 
          `Verified on blockchain\nTransaction hash: ${data.blockchain_hash.substring(0, 16)}...` :
          'Blockchain verification pending'
      }
    ],
    footer: 'Generated by SecureAI DeepFake Detection System'
  };
};

/**
 * Generate JSON preview data
 */
const generateJSONPreview = (data) => {
  return {
    analysis_id: data.analysis_id || 'sample-12345',
    timestamp: new Date().toISOString(),
    detection_results: {
      overall_confidence: data.overall_confidence || 0.85,
      is_fake: data.is_fake || false,
      processing_time_ms: data.processing_time_ms || 1250,
      model_used: 'Enhanced CNN Ensemble',
      blockchain_verification: {
        verified: !!data.blockchain_hash,
        transaction_hash: data.blockchain_hash || null,
        verification_timestamp: data.blockchain_hash ? new Date().toISOString() : null
      }
    },
    frame_analysis: (data.frame_analysis || []).slice(0, PREVIEW_SAMPLE_SIZE).map((frame, index) => ({
      frame_number: index + 1,
      confidence_score: frame.confidence || (0.7 + Math.random() * 0.3),
      suspicious_regions: frame.suspicious_regions || [],
      processing_time_ms: frame.processing_time_ms || 50
    })),
    metadata: {
      video_duration: data.video_duration || '00:02:30',
      frame_rate: data.frame_rate || 30,
      resolution: data.resolution || '1920x1080',
      file_size_mb: data.file_size_mb || 45.2
    }
  };
};

/**
 * Generate CSV preview data
 */
const generateCSVPreview = (data) => {
  const headers = [
    'Analysis ID',
    'Timestamp',
    'Is Fake',
    'Confidence Score',
    'Processing Time (ms)',
    'Model Used',
    'Blockchain Verified',
    'Transaction Hash'
  ];
  
  const rows = [
    [
      data.analysis_id || 'sample-12345',
      new Date().toISOString(),
      data.is_fake ? 'TRUE' : 'FALSE',
      data.overall_confidence || 0.85,
      data.processing_time_ms || 1250,
      'Enhanced CNN Ensemble',
      data.blockchain_hash ? 'TRUE' : 'FALSE',
      data.blockchain_hash || ''
    ]
  ];
  
  // Add frame analysis rows if available
  if (data.frame_analysis && data.frame_analysis.length > 0) {
    const frameHeaders = [
      'Frame Number',
      'Confidence Score',
      'Suspicious Regions Count',
      'Processing Time (ms)'
    ];
    
    const frameRows = data.frame_analysis.slice(0, PREVIEW_SAMPLE_SIZE).map((frame, index) => [
      index + 1,
      frame.confidence || (0.7 + Math.random() * 0.3),
      frame.suspicious_regions ? frame.suspicious_regions.length : 0,
      frame.processing_time_ms || 50
    ]);
    
    return {
      headers: [...headers, ...frameHeaders],
      rows: [
        [...rows[0], ...frameHeaders.map(() => '')], // Empty values for frame headers in main row
        ...frameRows.map(row => [...new Array(headers.length).fill(''), ...row])
      ]
    };
  }
  
  return { headers, rows };
};

// ============================================================================
// Main Component
// ============================================================================

/**
 * ExportFormatPreview - Format-specific preview component
 * 
 * @param {Object} props - Component properties
 * @param {string} props.format - Export format ('pdf', 'json', 'csv')
 * @param {Object} props.data - Preview data object
 * @param {Function} props.onClose - Callback when preview is closed
 * @returns {JSX.Element} ExportFormatPreview component
 */
const ExportFormatPreview = ({
  format,
  data,
  onClose
}) => {
  
  // ============================================================================
  // State Management
  // ============================================================================
  
  const [activeTab, setActiveTab] = useState('preview');
  
  // ============================================================================
  // Computed Values
  // ============================================================================
  
  const formatConfig = useMemo(() => {
    return FORMAT_PREVIEW_CONFIGS[format] || FORMAT_PREVIEW_CONFIGS.json;
  }, [format]);
  
  const previewData = useMemo(() => {
    switch (format) {
      case 'pdf':
        return generatePDFPreview(data);
      case 'json':
        return generateJSONPreview(data);
      case 'csv':
        return generateCSVPreview(data);
      default:
        return data;
    }
  }, [format, data]);
  
  // ============================================================================
  // Event Handlers
  // ============================================================================
  
  const handleTabChange = useCallback((tab) => {
    setActiveTab(tab);
  }, []);
  
  const handleDownloadSample = useCallback(() => {
    // Generate sample file download
    const sampleData = previewData;
    let mimeType, filename, content;
    
    switch (format) {
      case 'json':
        mimeType = 'application/json';
        filename = 'sample-detection-result.json';
        content = JSON.stringify(sampleData, null, 2);
        break;
      case 'csv':
        mimeType = 'text/csv';
        filename = 'sample-detection-result.csv';
        const csvContent = [
          sampleData.headers.join(','),
          ...sampleData.rows.map(row => row.join(','))
        ].join('\n');
        content = csvContent;
        break;
      case 'pdf':
        // PDF download would require server-side generation
        alert('PDF sample download requires server-side generation');
        return;
      default:
        return;
    }
    
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [format, previewData]);
  
  // ============================================================================
  // Render Functions
  // ============================================================================
  
  const renderPDFPreview = () => (
    <div className={styles.pdfPreview}>
      <div className={styles.pdfPage}>
        <div className={styles.pdfHeader}>
          <div className={styles.pdfLogo}>SecureAI</div>
          <div className={styles.pdfTitle}>{previewData.title}</div>
          <div className={styles.pdfSubtitle}>{previewData.subtitle}</div>
        </div>
        
        <div className={styles.pdfContent}>
          {previewData.sections.map((section, index) => (
            <div key={index} className={styles.pdfSection}>
              <h3 className={styles.pdfSectionTitle}>{section.title}</h3>
              <p className={styles.pdfSectionContent}>{section.content}</p>
            </div>
          ))}
        </div>
        
        <div className={styles.pdfFooter}>
          <div className={styles.pdfFooterText}>{previewData.footer}</div>
          <div className={styles.pdfPageNumber}>Page 1</div>
        </div>
      </div>
    </div>
  );
  
  const renderJSONPreview = () => (
    <div className={styles.jsonPreview}>
      <pre className={styles.jsonCode}>
        {JSON.stringify(previewData, null, 2)}
      </pre>
    </div>
  );
  
  const renderCSVPreview = () => (
    <div className={styles.csvPreview}>
      <table className={styles.csvTable}>
        <thead>
          <tr>
            {previewData.headers.map((header, index) => (
              <th key={index} className={styles.csvHeader}>
                {header}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {previewData.rows.map((row, rowIndex) => (
            <tr key={rowIndex} className={styles.csvRow}>
              {row.map((cell, cellIndex) => (
                <td key={cellIndex} className={styles.csvCell}>
                  {cell}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
      {previewData.rows.length >= PREVIEW_SAMPLE_SIZE && (
        <div className={styles.csvNote}>
          Showing first {PREVIEW_SAMPLE_SIZE} rows. Full export will include all data.
        </div>
      )}
    </div>
  );
  
  const renderPreview = () => {
    switch (format) {
      case 'pdf':
        return renderPDFPreview();
      case 'json':
        return renderJSONPreview();
      case 'csv':
        return renderCSVPreview();
      default:
        return <div>Preview not available for this format</div>;
    }
  };
  
  const renderDataStructure = () => (
    <div className={styles.dataStructure}>
      <h4>Data Structure</h4>
      <div className={styles.structureInfo}>
        {format === 'pdf' && (
          <ul>
            <li>Professional report layout</li>
            <li>Executive summary section</li>
            <li>Detailed detection results</li>
            <li>Blockchain verification status</li>
            <li>Company branding and formatting</li>
          </ul>
        )}
        {format === 'json' && (
          <ul>
            <li>Complete analysis metadata</li>
            <li>Frame-by-frame analysis data</li>
            <li>Blockchain verification details</li>
            <li>Processing metrics and timestamps</li>
            <li>Machine-readable format</li>
          </ul>
        )}
        {format === 'csv' && (
          <ul>
            <li>Tabular summary data</li>
            <li>Analysis ID and timestamps</li>
            <li>Confidence scores and results</li>
            <li>Processing time metrics</li>
            <li>Import-ready format</li>
          </ul>
        )}
      </div>
    </div>
  );
  
  // ============================================================================
  // Main Render
  // ============================================================================
  
  return (
    <div className={styles.exportFormatPreview}>
      <div className={styles.previewHeader}>
        <div className={styles.previewTitle}>
          <span className={styles.previewIcon}>{formatConfig.icon}</span>
          <div>
            <h3>{formatConfig.name}</h3>
            <p>{formatConfig.description}</p>
          </div>
        </div>
        <button
          onClick={onClose}
          className={styles.closeButton}
          aria-label="Close preview"
        >
          âœ•
        </button>
      </div>
      
      <div className={styles.previewTabs}>
        <button
          onClick={() => handleTabChange('preview')}
          className={`${styles.tab} ${activeTab === 'preview' ? styles.tabActive : ''}`}
        >
          Preview
        </button>
        <button
          onClick={() => handleTabChange('structure')}
          className={`${styles.tab} ${activeTab === 'structure' ? styles.tabActive : ''}`}
        >
          Data Structure
        </button>
      </div>
      
      <div className={styles.previewContent}>
        {activeTab === 'preview' && (
          <div className={styles.previewContainer}>
            {renderPreview()}
            <div className={styles.previewActions}>
              <button
                onClick={handleDownloadSample}
                className={styles.downloadSampleButton}
              >
                Download Sample
              </button>
            </div>
          </div>
        )}
        
        {activeTab === 'structure' && renderDataStructure()}
      </div>
    </div>
  );
};

export { ExportFormatPreview };
export default ExportFormatPreview;
